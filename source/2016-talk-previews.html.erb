<h3>2016 talk previews</h3>

<p>
  for 2016, i am focusing on more technical talks, both in backend and frontend technologies. the topics outlined below are by no means official talk descriptions, nor are they ready for submission to a CFP. they're brief explanations about the topics i'm looking into and doing more research on, before i've actually done the research. think of it as a peak into my brain during the very early stages of talk prep.
</p>

<p>
  want me to give one of these talks at your conference or interested in hearing more? perhaps even seeing a proper CFP where i care about grammar lololol? get in touch: <a href="mailto:me@liz.codes">me@liz.codes</a>.
</p>

<h4>in defense of static sites</h4>

<p>
  the most basic sites don't need servers, and they don't need fancy front end routing. and yet...
</p>

<p>
  how did we get here, and why are we so afraid to go back to the basics? who are we actually building these sites for and who are we harming by frontloading so many build tools, complex frameworks, and overblown architecture? hint: it's not just us, it's out users, too.
</p>

<p>
  static sites serve a purpose, and they're really important pieces of the web's history <em>and</em> its future. static doesn't mean <em>forever unchanged</em> and it doesn't mean you're stuck with a dead site that you can never update. quite frankly, static sites have gotten a bad reputation, and it's not their fault.
</p>

<p>
  i'd like to revisit what it means to build a static site, what the use cases are, how you know its right, what tools to use, and when to scale up to something more complex.
</p>

<h4>building complex static sites using data APIs, ruby, and middleman</h4>

<p>
  in this practical code-based talk, i'll go over a real use case for building a static site that leverages APIs and the power of ruby using middleman. i'll walk through the code samples and the ruby architecture, as well as outline best practices for building static sites using this pattern. this technical talk will use building a portfolio for a knitting pattern designer as an example, and can be suited for beginner or advanced audiences.
</p>

<h4>too many tools and too few carpenters</h4>

<p>
  i have a favorite interview question i like to ask front end developers: can you build a standards-compliant HTML5 page without using the internet to search for boilerplates, templates, or examples? show me.
</p>

<p>
  you'd be surprised how many front end developers have lost this skill over time. we've taken so much effort to remove things that some consider to be pain points in development, but we haven't put enough thought into whether or not we're maintaining a strong foundation that enables us to build the web.
</p>

<p>
  i'm a big believer that you don't have to know everything about a stack to work at a specific level, but we've gone so far away from the basics of front end development that we are breaking experiences for users. the web isn't accessible, our user interfaces have become increasingly complicated, and all of the hot topics in front end development focus solely on the cutting edge tools, frameworks, and practices.
</p>

<p>
  so, how do we fix this? i have a lot of ideas for you.
</p>

<h4>transitioning to services</h4>

<p>
  so, you've built yourself a service and you're ready to convert your monolithic app to use this service instead of your old dependency. how do you do this?
</p>

<p>
  as developers, we love to talk about extracting and building services because they're shiny and new... but we really hate to talk about how to actually transition to the service. how do you tackle the ocean of legacy code you're about to wade into? how do you determine the engineering time the transition will take, and how do you decide which engineers to use? how do you know when you're done?
</p>

<p>
  this talk will outline a transition we recently went through at new relic with one of our new services from our biggest code base, sharing best practices, mistakes, and challenges.
</p>

<h4>your css is terrible and it's all sass's fault</h4>

<p>
  when was the last time you wrote css without any auto prefixers, compilers, or other dev tools? probably awhile - unless you find joy in writing simple css for small personal projects like me.
</p>

<p>
  while i love sass and its many benefits, it's difficult to write good css unless you really know what you're doing. it's so convenient and easy to use that it often sets developers up for failure - unwittingly leading them to produce bugs they don't know how to pinpoint and complicated css full of confusing declarations.
</p>

<p>
  let's talk about the common traps we fall into with sass, how to fix them, and how to prevent them in the future.
</p>

<h4>creating a versioning system for sass that scales</h4>

<p>
  whether you are writing an internal style guide or building your own css framework, the questioning of versioning comes up somewhere. how do you do it? how do you leverage the tools you're already using to help version your system? this short, simple talk will provide you with a strategy that's easy to implement and, for those with extracted sass, requires very few changes to your production environment. compiling your assests on your server? i've got a solution for you, too - it's just a bit more complicated.
</p>